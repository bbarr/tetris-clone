{
  "name": "medium",
  "version": "0.1.1",
  "description": "CSP-style channel library using ES7 async/await keywords",
  "main": "./lib/index.js",
  "scripts": {
    "test": "mocha --watch --compilers js:babel/register"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/bbarr/medium.git"
  },
  "keywords": [
    "CSP",
    "channels",
    "async"
  ],
  "author": {
    "name": "Brendan Barr",
    "email": "bbarr1384@gmail.com",
    "url": "http://replwithoutacause.com"
  },
  "license": "ISC",
  "devDependencies": {
    "sinon": "^1.15.3",
    "transducers-js": "^0.4.174"
  },
  "readme": "# Medium\nCSP-style channel library using ES7 async/await keywords\n\n####Installation\n\n```javascript\nnpm install medium\n```\n\nYou will need to use BabelJS, of course, to add ES7 support to your project.\n\n####Why another CSP library?\nThere is currently only one with any traction ([js-csp](https://github.com/ubolonton/js-csp)), so another interpretation is a chance to view the subject from a different angle. Specifically, Medium tries to take CSP further into the future by embracing ES7 async/await as well as the trend towards choosing promises over callbacks. Relying on promises means that we can easily interact with other generator libraries, such as Koa.\n\n####What the heck is CSP? What are channels?\nI am hoping to write a bit more on this sometime, but for now, there are loads of great articles by smarter people than me, explaining the ins and outs, as well as the motivation of using \"Communicating Sequential Processes\".\n\n* [CSP and transducers in JavaScript](http://phuu.net/2014/08/31/csp-and-transducers.html)\n* [Taming the Asynchronous Beast with CSP Channels in JavaScript](http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript)\n* Check out the documentation at the above mentioned js-csp library. Different implementation, but the API and core principles are quite aligned.\n\n####Let's, start with a trivial example\n\n```javascript\n\nimport channels from 'channels'\n\nvar { go, chan, take, put, sleep } = channels\n\nvar ch = chan()\n\ngo(async function() {\n  while (true) {\n    // will print 1, wait 200ms, print 2\n    console.log(await take(ch))\n  }\n})\n\ngo(async function() {\n  await put(ch, 1)\n  await sleep(200)\n  await put(ch, 2)\n})\n```\n\nWe can also interact with channels outside go/async blocks.\n\n```javascript\n\nimport channels from 'channels'\n\nvar { chan, take, put } = channels\n\nvar ch = chan()\n\ntake(ch).then((val) => console.log('taking: ', val))\nput(ch, 'hi').then(() => console.log('we put!'))\n\n// will print, in this order:\n// 'we put!'\n// 'taking: hi'\n```\n\n####Buffers\nBy default, a channel will block a put until a corrosponding take shows up. Buffers are a way to define different strategies for handling this behavior.\n\n####Fixed\n\nA fixed buffer immediately accepts N puts. These ```put``` actions have their promises resolved with ```true``` and queue up their value for a respective ```take```.\nWhen it has reached N values, it begins to buffer and will park a ```put``` action until there is space for its value.\n\n```javascript\nimport channels from 'channels'\n\nvar { go, chan, take, put, sleep, buffers } = channels\n\nvar ch = chan(buffers.fixed(2)) // alias chan(2)\n\ngo(async function() {\n\n  await put(ch, 1)\n  await put(ch, 2)\n\n  console.log('buffer full...')\n\n  await put(ch, 3)\n\n  console.log('finally, 3 added to buffer')\n})\n\ngo(async function() {\n\n  await sleep(1000)\n\n  // this take() will create room for the 3\n  await take(ch)\n})\n```\n\n###Dropping\n\nThis is just like the fixed buffer, except\nit actually drops (ignores) any excess ```put```s.\n\n```javascript\nvar ch = chan(buffers.dropping(2))\n\ngo(async function() {\n  await sleep(1000)\n  console.log('waited a second')\n  console.log('this should be a 1:', await take(ch))\n  console.log('this should be a 2:', await take(ch))\n  await take(ch)\n  console.log('this will just be queued, because the three was dropped and there are no pending puts')\n\n})\n\ngo(async function() {\n\n  await put(ch, 1)\n  await put(ch, 2)\n\n  console.log('buffer full...')\n\n  console.log('this 3 gets dropped')\n  await put(ch, 3)\n  console.log('and is released immediately')\n})\n```\n\n###Sliding\n\nThis is just like the fixed buffer, except\nit will push a new ```put``` value while simultaneously dropping the oldest ```put``` value.\n\n```javascript\nimport channels from 'channels'\n\nvar { go, chan, take, put, sleep, buffers } = channels\n\nvar ch = chan(buffers.sliding(2))\n\ngo(async function() {\n  await sleep(1000)\n  console.log('waited a second')\n  console.log('this should be a 2:', await take(ch))\n  console.log('this should be a 3:', await take(ch))\n})\n\ngo(async function() {\n\n  await put(ch, 1)\n  await put(ch, 2)\n\n  console.log('buffer full...')\n\n  console.log('this 3 gets slid into the last spot, dropping the first (1)')\n  await put(ch, 3)\n  console.log('and is released immediately')\n\n})\n```\n\n##Advanced\n\n###Transducers\nYou can use transducers!\n\n```javascript\nimport channels from '../lib/index'\nimport t from 'transducers-js'\n\nvar { go, chan, take, put, sleep, buffers, pipe } = channels\n\nvar allowEven = t.filter((n) => n % 2 === 0)\nvar ch = chan(2, allowEven)\n\ngo(async function() {\n  console.log(await take(ch))\n  console.log(await take(ch))\n})\n\nput(ch, 1)\nput(ch, 2)\nput(ch, 3)\n```\n\n###Pipe\n\n```javascript\nimport channels from '../lib/index'\nimport t from 'transducers-js'\n\nvar { go, chan, take, put, ops } = channels\nvar pipe = ops.pipe\n\nvar isEven = (n) => n % 2 === 0\nvar inc = (n) => n + 1\n\nvar ch1 = chan()\nvar ch2 = chan(10, t.filter(isEven))\nvar ch3 = chan(10, t.map(inc))\npipe(ch1, ch2)\npipe(ch2, ch3)\n\ngo(async function() {\n  while (true) {\n    // will log 3, 5\n    console.log(await take(ch3))\n  }\n})\n\nput(ch1, 1)\nput(ch1, 2)\nput(ch1, 3)\nput(ch1, 4)\nput(ch1, 5)\n```\n\n###Mult\n\n```javascript\nimport channels from '../lib/index'\n\nvar { go, chan, take, put, ops } = channels\nvar mult = ops.mult\n\nvar ch1 = mult(chan())\nvar ch2 = chan()\nvar ch3 = chan()\n\nmult.tap(ch1, ch2)\nmult.tap(ch1, ch3)\n\ngo(async function() {\n  while (true) {\n    // will log 1, 2, 3, 4, 5\n    console.log(await take(ch2))\n  }\n})\n\ngo(async function() {\n  while (true) {\n    // will log 1, 2, 3, 4, 5\n    console.log(await take(ch3))\n  }\n})\n\nput(ch1, 1)\nput(ch1, 2)\nput(ch1, 3)\nput(ch1, 4)\nput(ch1, 5)\n```\n\n##API \n\n###chan(numOrBuffer, xducer)\n###put(ch, val)\n###take(ch)\n###go(async function)\n###sleep(ms)\n###close(ch)\n###buffers\n- unbuffered()\n- fixed(num)\n- sliding(num)\n- dropping(num)\n\n###Ops\n- pipe(srcCh, destCh)\n- mult(ch)\n  - tap(srcCh, destCh)\n  - untap(srcCh, destCh)\n\n\n\n",
  "readmeFilename": "README.md",
  "gitHead": "a673b91dd3fcdcc10ad84069625011d84f92edd0",
  "bugs": {
    "url": "https://github.com/bbarr/medium/issues"
  },
  "homepage": "https://github.com/bbarr/medium#readme",
  "_id": "medium@0.1.1",
  "_shasum": "ac5c68135ec0df0bd852c4a0bba9ba57a3b41c96",
  "_from": "medium@*"
}
